---
title: 자바 백엔드 실무 #1 - 엔터프라이즈 UI의 표준, Spring Boot와 NEXACRO 연동 아키텍처
date: 2025-11-10 00:00:00 +0900
categories: [DevLog, Java, Architecture]
tags: [java, spring boot, nexacro, si, x-api, uiadapter, architecture]
---

## 들어가며

최근 웹 개발 트렌드는 React나 Vue.js와 같은 프론트엔드 프레임워크가 주도하고 있습니다. 하지만 금융, 공공, 그리고 특히 **방산 및 기업형 자산관리 시스템(ERP)** 분야에서는 이야기가 조금 다릅니다. 복잡한 그리드(Grid) 처리와 대량의 데이터 핸들링, 그리고 빠른 화면 개발 생산성이 요구되는 이곳에서는 여전히 **NEXACRO(넥사크로)**와 같은 전문 UI 플랫폼이 강력한 표준으로 자리 잡고 있습니다.

제가 지원하고자 하는 시스템 운영 및 유지보수 업무 역시 **Spring Framework** 기반의 견고한 백엔드 위에 **NEXACRO**를 얹은 아키텍처를 채택하고 있습니다. 이는 안정성과 성능, 그리고 개발 효율성을 모두 잡기 위한 선택입니다.

이번 [자바 백엔드 실무] 시리즈의 첫 시작은, 단순한 코딩을 넘어 **시스템의 뼈대를 이해하는 것**에서 출발합니다. Spring Boot 백엔드와 NEXACRO 프론트엔드가 어떻게 데이터를 주고받는지, 그 핵심 아키텍처와 공통 모듈 설계 전략을 살펴보겠습니다.

## 데이터 통신의 이해: JSON이 아니다?

일반적인 REST API 서비스는 JSON 형식으로 데이터를 주고받습니다. 하지만 넥사크로는 독자적인 통신 포맷을 사용합니다. 바로 **PlatformData**라는 구조 안에 **VariableList(변수 목록)**와 **DataSetList(데이터셋 목록)**를 담아 통신합니다.

따라서 Spring Boot가 넥사크로와 대화하기 위해서는 중간에서 통역사 역할을 하는 존재가 필요합니다.

1.  **Request:** 클라이언트(NEXACRO)가 보낸 XML/SSV 포맷 데이터를 자바 객체로 변환
2.  **Response:** 자바 객체(List, Map, DTO)를 다시 넥사크로가 이해할 수 있는 포맷으로 변환

이 과정을 매번 컨트롤러에서 하드코딩하는 것은 비효율적입니다. 여기서 **UiAdapter** 개념이 등장합니다.

## 아키텍처 설계: UiAdapter와 ArgumentResolver

5년 차 이상의 개발자, 특히 PL(Project Leader) 역할을 수행한다면 개발 팀원들이 비즈니스 로직에만 집중할 수 있도록 **공통 프레임워크**를 구성해야 합니다.

Spring MVC 구조에서 이를 우아하게 처리하는 방법은 `HandlerMethodArgumentResolver`와 `HandlerMethodReturnValueHandler`를 커스터마이징 하는 것입니다. 투비소프트에서 제공하는 **X-API** 라이브러리를 활용하여 이를 구현해 봅시다.

```java
// 넥사크로 연동을 위한 Configuration 예시
@Configuration
public class NexacroConfig implements WebMvcConfigurer {

    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        // 요청 데이터를 NexacroPlatformData로 자동 변환해주는 Resolver 등록
        resolvers.add(new NexacroArgumentResolver());
    }

    @Override
    public void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers) {
        // 리턴 데이터를 넥사크로 포맷으로 자동 변환해주는 Handler 등록
        handlers.add(new NexacroReturnValueHandler());
    }
}
```

이렇게 설정을 잡아두면, 개발자들은 컨트롤러에서 복잡한 파싱 로직 없이도 넥사크로 데이터를 편하게 받을 수 있습니다.

## 실전 구현: 표준 컨트롤러 패턴

SI 프로젝트나 운영 업무를 하다 보면, 수십 명의 개발자가 제각각의 스타일로 코드를 짜는 경우가 많습니다. 이는 유지보수의 재앙이 됩니다. 따라서 **표준 코딩 가이드**를 위한 컨트롤러 패턴을 정립하는 것이 중요합니다.

다음은 제가 주로 사용하는 넥사크로 연동 컨트롤러의 표준 패턴입니다.

```java
@Controller
public class AssetController {

    @Resource(name = "assetService")
    private AssetService assetService;

    /**
     * 자산 목록 조회
     * @param inData : 넥사크로에서 넘어온 검색 조건 (DataSet)
     * @return NexacroResult : 넥사크로로 보낼 결과 데이터
     */
    @RequestMapping(value = "/asset/list.do")
    public NexacroResult searchAssetList(@ParamDataSet(name = "dsSearch") Map<String, Object> searchMap) {
        
        NexacroResult result = new NexacroResult();
        
        try {
            // 1. 비즈니스 로직 수행 (MyBatis 연동)
            List<Map<String, Object>> assetList = assetService.selectAssetList(searchMap);
            
            // 2. 결과 데이터셋 세팅 (PlatformData 자동 변환)
            result.addDataSet("dsList", assetList);
            
            // 3. 성공 메시지 처리 (공통 코드 활용)
            result.setErrorCode(0);
            result.setErrorMsg("조회되었습니다.");
            
        } catch (Exception e) {
            // 예외 발생 시 표준 에러 처리
            result.setErrorCode(-1);
            result.setErrorMsg("시스템 에러 발생: " + e.getMessage());
        }
        
        return result;
    }
}
```

### 코드의 핵심 포인트
1.  **`@ParamDataSet`**: 커스텀 어노테이션을 통해 넥사크로의 `dsSearch` 데이터셋을 Java의 `Map`으로 바로 매핑했습니다.
2.  **`NexacroResult`**: 리턴 타입을 통일하여, 데이터뿐만 아니라 트랜잭션 결과 코드(`ErrorCode`)와 메시지(`ErrorMsg`)를 일관성 있게 처리합니다.

## 마무리하며

오늘은 자산관리 시스템 구축의 첫 단추인 **Spring과 NEXACRO의 연동 아키텍처**를 살펴보았습니다. 단순히 데이터를 주고받는 것을 넘어, `ArgumentResolver`를 통해 **통신 로직을 추상화**하고, 표준화된 컨트롤러 패턴을 통해 **유지보수성**을 높이는 것이 핵심입니다.

특히 기존 `MiPlatform` 시절부터 이어져 온 X-API의 특성을 잘 이해하고 있어야, 레거시 시스템을 분석하거나 차세대 시스템으로 고도화할 때 발생할 수 있는 시행착오를 줄일 수 있습니다.

하지만 뼈대만 있다고 시스템이 완성되는 것은 아닙니다. 기업형 시스템, 특히 자산관리나 ERP에서는 **수만 건 이상의 데이터**를 한 화면에 보여줘야 하는 상황이 빈번합니다.

다음 글에서는 이 아키텍처 위에서 **대용량 데이터를 어떻게 빠르게 조회하고 처리할 것인지**, 넥사크로의 **SSV 통신**과 **페이징 처리** 기법을 통해 성능 최적화 노하우를 공유하겠습니다.