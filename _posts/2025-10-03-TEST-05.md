---
title: Unable to find @SpringBootConfiguration 오류 해결
date: 2025-10-03 00:30:00 +0900
categories: [공부, Spring Boot, Testing]
tags: [spring-boot-test, configuration, troubleshooting]
---

Spring Boot 테스트 실행 중 `@SpringBootConfiguration`을 찾을 수 없다는 오류가 발생했다. 이 문제의 원인과 해결 과정을 정리한다.

## 오류 내용

```
java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration by searching packages upwards from the test. 
You can use @ContextConfiguration, @SpringBootTest(classes=...) or other Spring Test supported mechanisms 
to explicitly declare the configuration classes to load.
```

## 문제 원인

ComponentScan의 exclude 필터가 너무 광범위해서 메인 애플리케이션 클래스까지 제외하고 있었다:

```
@ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Test.*")
```

이 패턴이 `ServerApplicationTests`뿐만 아니라 다른 클래스들도 의도치 않게 제외시키고 있었다.

## 해결 방법

### 방법 1: 테스트에서 명시적으로 클래스 지정

```
@SpringBootTest(classes = ServerApplication.class)  // 메인 클래스 명시
@ActiveProfiles("test")
class ServerApplicationTests {

    @Test
    void contextLoads() {
        // Spring Context 로드 테스트
    }
}
```

### 방법 2: ComponentScan 필터 수정

```
@SpringBootApplication
@ComponentScan(
    basePackages = "kr.hhplus.be.server",
    excludeFilters = {
        @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Test[s]?$") // 더 정확한 패턴
    }
)
public class ServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerApplication.class, args);
    }
}
```

### 방법 3: ComponentScan 완전 제거 (권장)

```
@SpringBootApplication  // ComponentScan 어노테이션 제거
public class ServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerApplication.class, args);
    }
}
```

이 방법이 가장 안전하다. Spring Boot가 기본적으로 제공하는 패키지 스캔을 사용하면 예상치 못한 필터링 문제를 피할 수 있다.

## 모든 통합 테스트에 적용

```
@SpringBootTest(classes = ServerApplication.class)
@ActiveProfiles("test")
@Transactional
public class ConcertReservationFlowIntegrationTest {
    // 테스트 코드
}

@SpringBootTest(classes = ServerApplication.class)
@ActiveProfiles("test")
public class ConcurrentSeatReservationTest {
    // 테스트 코드
}
```

## 추가 고려사항

테스트별로 특별한 Configuration이 필요한 경우, TestConfiguration을 별도로 생성하여 사용할 수 있다:

```
@TestConfiguration
public class TestConfig {
    
    @Bean
    @Primary
    public PaymentGateway testPaymentGateway() {
        return payment -> payment.complete("test-txn-" + System.currentTimeMillis());
    }
}

@SpringBootTest(classes = {ServerApplication.class, TestConfig.class})
@ActiveProfiles("test")
public class PaymentIntegrationTest {
    // 테스트 코드
}
```

## 결론

ComponentScan 필터를 사용할 때는 의도하지 않은 클래스 제외가 발생하지 않도록 주의해야 한다. 가능하면 Spring Boot의 기본 스캔 방식을 사용하고, 필요한 경우에만 명시적으로 클래스를 지정하는 것이 안전하다.